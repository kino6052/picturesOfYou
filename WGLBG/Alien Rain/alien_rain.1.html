<html>

<head>
<title>WebGL Beginner's Guide - Chapter 3 - Goraud Shading + Lambertian Reflection Model</title>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<!-- CSS Styles //-->
<link href='css/style.css'   type='text/css' rel='stylesheet'>
<link href='css/desert.css'  type='text/css' rel='stylesheet'/>
<link href='css/colorpicker.css'  type='text/css' rel='stylesheet'/>
<link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />

<!-- JavaScript Libraries //-->
<script type='text/javascript' src='js/gl-matrix-min.js'></script>
<script type='text/javascript' src='js/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/prettify.js'></script>
<script type='text/javascript' src='js/utils.js'></script>
<script type='text/javascript' src='js/colorpicker.js'></script>
<script type='text/javascript' src='js/codeview.js'></script>
<script type='text/javascript' src='modules/affine-transformations.js'></script>
<script type='text/javascript' src='modules/tv.js'></script>

<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;

uniform vec3 uLightDirection;   //light direction
uniform vec4 uLightDiffuse;     //light color
uniform vec4 uMaterialDiffuse;  //object color

uniform bool uIsTextureEnabled;

varying vec2 vTextureCoord;

varying vec4 vFinalColor;

void main(void) {
 //Transformed normal position
 vec3 N = normalize(vec3(uNMatrix * vec4(aVertexNormal, 1.0)));
    
 //Normalize light to calculate lambertTerm
 vec3 L = normalize(uLightDirection);
 
 //Lambert's cosine law
 float lambertTerm = dot(N,-L);
 
 //Final Color
 vec4 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
 vFinalColor = Id;
 
 if (uIsTextureEnabled) {
     vFinalColor.a = 1.0;
     vTextureCoord = aTextureCoord;
 }
 if (!uIsTextureEnabled) {
     vFinalColor.a = 1.0;
 }
    
  //Transformed vertex position
  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D uSampler;
uniform bool uIsTextureEnabled;
varying vec2 vTextureCoord;
varying vec4  vFinalColor;

void main(void)  {
 
 if (uIsTextureEnabled) {
     gl_FragColor = texture2D(uSampler, vTextureCoord);
 }
 if (!uIsTextureEnabled) {
     gl_FragColor = vFinalColor; //texture2D(uSampler, vTextureCoord);
 }
}
</script>


<script id='code-js' type="text/javascript">

var gl = null; // WebGL context
var prg = null; // The program (shaders)
var c_width = 0; // Variable to store the width of the canvas
var c_height = 0; // Variable to store the height of the canvas

var mvMatrix = mat4.create(); // The Model-View matrix
var pMatrix = mat4.create(); // The projection matrix

/*-----------------------------------------------------*/
var nMatrix =  mat4.create();       // The normal matrix
/*-----------------------------------------------------*/

var sphereVerticesBuffer;
var sphereIndicesBuffer;
var screenVerticesBuffer;
var screenIndicesBuffer;
var screenNormalsBuffer;
var dataArrayBuffer;

/*-----------------------------------------------------*/
var sphereNormalsBuffer;               //VBO for Normals
/*-----------------------------------------------------*/
var dropletIndicesBuffer;
var cubeVertexTextureCoordBuffer;

var vertices;
var indices;
/*-----------------------------------------------------*/
var normals;              //JavaScript Array for Normals
/*-----------------------------------------------------*/
var textureCoords;
var affineTransformationsArray = [];

var mode = 1;

var angle = 0;

/* DROPLET PROPERTIES (AFFINE TRANSFORMATIONS)
*  
*  Project Location: modules/affine-transformations.js)
*  Description: an array is created that holds information about
*  rotation and position of particles
*/

var dropletQuantity = 100;
var speed = 0.01;
var rotationSpeed = 0.01;
var spread = 3000;

/**
* The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
* what to do with every vertex and fragment that we pass it. 
* The vertex shader and the fragment shader together are called the program.
*/
function initProgram() {
    var fragmentShader          = utils.getShader(gl, "shader-fs");
    var vertexShader            = utils.getShader(gl, "shader-vs");

    prg = gl.createProgram();
    gl.attachShader(prg, vertexShader);
    gl.attachShader(prg, fragmentShader);
    gl.linkProgram(prg);

    if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(prg);

    prg.aVertexPosition  = gl.getAttribLocation(prg, "aVertexPosition");
    prg.aVertexNormal    = gl.getAttribLocation(prg, "aVertexNormal");
    prg.aTextureCoord = gl.getAttribLocation(prg, "aTextureCoord");
    
    prg.uPMatrix         = gl.getUniformLocation(prg, "uPMatrix");
    prg.uMVMatrix        = gl.getUniformLocation(prg, "uMVMatrix");
    prg.uNMatrix         = gl.getUniformLocation(prg, "uNMatrix");

    prg.uMaterialDiffuse  = gl.getUniformLocation(prg, "uMaterialDiffuse");
    prg.uLightDiffuse     = gl.getUniformLocation(prg, "uLightDiffuse");
    prg.uLightDirection   = gl.getUniformLocation(prg, "uLightDirection");
    
    prg.uIsTextureEnabled = gl.getUniformLocation(prg, "uIsTextureEnabled");
    
    prg.samplerUniform = gl.getUniformLocation(prg, "uSampler");
    
    
   
}


function initLights(){
    gl.uniform3fv(prg.uLightDirection,    [0.0, -1.0, -1.0]);
    gl.uniform4fv(prg.uLightDiffuse,      [1.0,1.0,1.0,1.0]); 
    gl.uniform4fv(prg.uMaterialDiffuse,   [0.5,0.8,0.1,1.0]);
}

/**
* This function generates SPHERE data and creates the buffers
*/
function initBuffers()
{
    screenVertices = [-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0];
	screenIndices = [0, 2, 1, 1, 2, 3];
	screenNormals = utils.calculateNormals(screenVertices, screenIndices);
    
    textureCoords = [
          0.0, 1.0,
          1.0, 1.0,
          0.0, 0.0,
          1.0, 0.0
    ];
	
	normals = utils.calculateNormals(tv.vertices, tv.indices);

	screenVerticesBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, screenVerticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(screenVertices), gl.DYNAMIC_DRAW);
	
	screenNormalsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, screenNormalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(screenNormals), gl.DYNAMIC_DRAW);

    
    

    screenIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIndicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(screenIndices), gl.DYNAMIC_DRAW);
	
	
    sphereVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tv.vertices), gl.DYNAMIC_DRAW);

    sphereNormalsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.DYNAMIC_DRAW);

    //if (mode == 0){
        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.DYNAMIC_DRAW);
        
        gl.enableVertexAttribArray(prg.aTextureCoord);
        gl.uniform1i(prg.samplerUniform, 0);
    //}
    

    sphereIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(tv.indices), gl.DYNAMIC_DRAW);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

}

/* MATRIX OPERATIONS */
var mvMatrixStack = [];

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

/* TEXTURE OPERATIONS */
function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,     gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,     gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        //gl.bindTexture(gl.TEXTURE_2D, null);
}


var neheTexture;
var backgroundTexture;

function initBackgroundTexture() {
    backgroundTexture = gl.createTexture();
    backgroundTexture.image = new Image();
    backgroundTexture.image.onload = function() {
        handleLoadedTexture(backgroundTexture);
    }
    backgroundTexture.image.src = "textures/bg.jpg";
}

function initTexture() {
    neheTexture = gl.createTexture();
    neheTexture.image = new Image();
    neheTexture.image.onload = function () {
        console.log("loaded video texture");
        handleLoadedTexture(neheTexture);
    };

    neheTexture.image.src = "polaroid.jpg";
}

/**
* Main rendering function. Called every 500ms according to WebGLStart function (see below)
*/
function drawScene() {
    var temp = angle % 1.0;
    gl.clearColor(temp, temp, temp, 1.0);//0.9,0.9,0.9, 1.0);
    gl.clearDepth(100.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	
	
    mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);
    
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [0.0, -1.3, -3.0]); //Sets the camera to a reasonable distance to view the part
    mat4.rotate(mvMatrix, -3.14*29/180, [1, 0, 0]);
    
    
    try{
        gl.enableVertexAttribArray(prg.aVertexPosition);
        gl.enableVertexAttribArray(prg.aVertexNormal);
        //mat4.rotate(mvMatrix, angle, [0,1,0]);
	    
        //2. bind buffers 
		//if (mode == 1){
		    gl.disableVertexAttribArray(prg.aTextureCoord);
			//mat4.translate(mvMatrix, [qnt/100, -0.5, -0.5]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [0, 0, 0]);
			
			mat4.scale(mvMatrix, [0.6, 0.6, 0.6]);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
			gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
			gl.vertexAttribPointer(prg.aVertexNormal,3,gl.FLOAT, false, 0,0);
            
            //gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
            //gl.vertexAttribPointer(prg.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
    
            //gl.activeTexture(gl.TEXTURE0);
            //gl.bindTexture(gl.TEXTURE_2D, neheTexture);
            //gl.uniform1i(prg.samplerUniform, 0);
            
            gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
        	gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);
        	
        	
        	gl.uniform1i(prg.uIsTextureEnabled, false); 
        	
            
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
			
			gl.drawElements(gl.TRIANGLES, tv.indices.length, gl.UNSIGNED_SHORT,0);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			//console.log("Just Drew a Square");
			mvPopMatrix();
		//}
		//if (mode == 0) {
		    gl.enableVertexAttribArray(prg.aTextureCoord);
		    //mat4.translate(mvMatrix, [qnt/100, -0.5, -0.5]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [-0.2, 0.7, 0.42]);
			
			mat4.scale(mvMatrix, [1.4, 1.05, 2.0]);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, screenVerticesBuffer);
			gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, screenNormalsBuffer);
			gl.vertexAttribPointer(prg.aVertexNormal,3,gl.FLOAT, false, 0,0);
            
            gl.uniform1i(prg.uIsTextureEnabled, true); 
            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
            gl.vertexAttribPointer(prg.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, neheTexture);

			if (videoready)
			{
				try
				{
					// upload the video frame
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
				}
				catch(e)
				{
					// log only the first few errors
					
				}
			}

            gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
        	gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);
            
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIndicesBuffer);
			
			gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT,0);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			//console.log("Just Drew a Square");
			mvPopMatrix();
			
			/*
			* BACKGROUND
			*/
			
			
		    //mat4.translate(mvMatrix, [qnt/100, -0.5, -0.5]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [0, 3, -4]);
			mat4.rotate(mvMatrix, 3.14*29/180, [1, 0, 0]);
			mat4.scale(mvMatrix, [14, 10, 10]);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, screenVerticesBuffer);
			gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, screenNormalsBuffer);
			gl.vertexAttribPointer(prg.aVertexNormal,3,gl.FLOAT, false, 0,0);
            
            gl.uniform1i(prg.uIsTextureEnabled, true); 
            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
            gl.vertexAttribPointer(prg.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, neheTexture);

		
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, backgroundTexture.image);
				

            gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
        	gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);
            
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIndicesBuffer);
			
			gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT,0);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			//console.log("Just Drew a Square");
			mvPopMatrix();
		//}
    }
    catch(err){
        alert(err);
        //message(err.description);
    }
	
    mat4.set(mvMatrix, nMatrix);
    mat4.inverse(nMatrix);
    mat4.transpose(nMatrix);
    
    gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);
	
	updateAffineTransformationsArray();
	angle+=0.001;
}


function initVideo() {
    
}


/**
* Render Loop
*/
function renderLoop() {
    requestAnimFrame(renderLoop);
    drawScene();
}

var video = document.createElement("video");
var videoready = false;
/**
* Entry point. This function is invoked when the page is loaded
*/
function runWebGLApp() {
	initAffineTransformationsArray();
    //Obtains a WebGL context
    gl = utils.getGLContext("canvas-element-id");
    //Initializes the program (shaders) 
    initProgram();
    //Initializes the buffers that we are going to use
    initBuffers();
    //Initializes lights
    initLights();
    //Renders the scene!
    // load the video
		
		video.autoplay = true;
		video.loop = true;
		video.oncanplay = function(){ videoready=true; }
		
		video.onerror = function()
		{
			var err = "unknown error";
			
			switch(video.error.code)
			{
				case 1: err = "video loading aborted"; break;
				case 2: err = "network loading error"; break;
				case 3: err = "video decoding failed / corrupted data or unsupported codec"; break;
				case 4: err = "video not supported"; break;
			}; 
			
			log("Error: " + err + " (errorcode="+video.error.code+")", "color:red;");
		};
		
		video.src = "video/pictures.mp4";

		// try to disable the iPhone video fullscreen mode:
		video.setAttribute("playsinline", "");
		video.setAttribute("webkit-playsinline", "");

		// try to start playing
		video.play();
        initTexture();
        initBackgroundTexture();
    
    
    renderLoop();
}
</script>
</head>

<body onLoad='runWebGLApp()'>
<div id='top'>
 <h1>WebGL Beginner's Guide - Chapter 3</h1>
 <h2>Goraud Shading + Lambertian Reflection Model</h2>
 <div id='logo-packt'><img src='packt.gif'/></div>
 <h3>Final Color = Id</h3>
</div>

<div id='contents'>
 <div id='canvasContainer'>
  <canvas id='canvas-element-id' width='480' height='400'>
   Your browser does not support the HTML5 canvas element.
  </canvas>
 </div>
    <div id='controls'>
        
    </div>
</div>

<div id='bottom'>
<table>
<tr>
<td>
<table>
  <caption>Light Direction</caption>
  <tr>
   <td>X:</td><td id='slider-x-value' width='30px' align='center'>0.0</td><td width='150px'><div id='slider-x'/></td>
  </tr>
  <tr>
   <td>Y:</td> <td id='slider-y-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-y'/></td>
  </tr>
  <tr>
   <td>Z:</td> <td id='slider-z-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-z'/></td>
  </tr>
 </table>
</td>
<td>
   <table>
   <tr>
             <td colspan="2"> Sphere Color (Material Diffuse Term:</td>
             <td>
                  <div id='colorSelectorSphere' class='colorSelector'><div style='background-color:rgb(128,204,26)'></div></div>
             </td>
    </tr>
    <tr>
         <td align='right'>Light Diffuse Term:</td>
         <td id='slider-ld-value'  width='30px'>1.0</td>
         <td width='150px' colspan='3'><div id='slider-ld'/></td>
     </tr>
    </table>
</td>
</tr>
</table>
</div>
<script>cview.run(cview.MODE_VIEW_AND_CONTROLS);</script>

<script>



function updateLightDiffuseTerm(){
 var ld = $('#slider-ld').slider("value");
 gl.uniform4fv(prg.uLightDiffuse,[ld,ld,ld,1.0]);
 $('#slider-ld-value').html(ld);
}

$('#slider-ld').slider({value:1.0, min:-0.01, max:1.01, step:0.01, slide:updateLightDiffuseTerm});


function updateLightDirection(){
   var x = $('#slider-x').slider("value");
   var y = $('#slider-y').slider("value");
   var z = $('#slider-z').slider("value");
   gl.uniform3fv(prg.uLightDirection, [x,y,z]);
   $('#slider-x-value').html(x);
   $('#slider-y-value').html(y);
   $('#slider-z-value').html(z);
}

$('#slider-x').slider({value:0.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-y').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-z').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});

function updateObjectColor(r,g,b){
    gl.uniform4fv(prg.uMaterialDiffuse,[r,g,b,1.0]); 
}

$('#colorSelectorSphere').ColorPicker({
    onSubmit: function(hsb, hex, rgb, el) {
   $(el).val(hex);
   $(el).ColorPickerHide();
   
 },
 color: '#00ff00',
    onShow: function (colpkr) {
        $(colpkr).fadeIn(500);
        return false;
    },
    onHide: function (colpkr) {
        $(colpkr).fadeOut(500);
        return false;
    },
    onChange: function (hsb, hex, rgb) {
        $('#colorSelectorSphere div').css('backgroundColor', '#' + hex);
        updateObjectColor(rgb.r/256,rgb.g/256,rgb.b/256);
    },
    
    onBeforeShow: function (colpkr) {
   $(colpkr).ColorPickerSetColor('rgb(0.5,0.8,0.1)');
  }
 })

</script>
<audio id="audio" src="pics.mp3" preload="auto"></audio>
</body>
</html>
