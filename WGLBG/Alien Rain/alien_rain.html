<html>

<head>
<title>WebGL Beginner's Guide - Chapter 3 - Goraud Shading + Lambertian Reflection Model</title>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<!-- CSS Styles //-->
<link href='css/style.css'   type='text/css' rel='stylesheet'>
<link href='css/desert.css'  type='text/css' rel='stylesheet'/>
<link href='css/colorpicker.css'  type='text/css' rel='stylesheet'/>
<link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />

<!-- JavaScript Libraries //-->
<script type='text/javascript' src='js/gl-matrix-min.js'></script>
<script type='text/javascript' src='js/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/prettify.js'></script>
<script type='text/javascript' src='js/utils.js'></script>
<script type='text/javascript' src='js/colorpicker.js'></script>
<script type='text/javascript' src='js/codeview.js'></script>

<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
//attribute vec3 aTemp;
attribute vec3 aVertexNormal;
attribute float aIndex; // index of a rain particle

uniform vec2 uDataArray; // array with data for each particle (offset and rotation)

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;

uniform vec3 uLightDirection;   //light direction
uniform vec4 uLightDiffuse;     //light color
uniform vec4 uMaterialDiffuse;  //object color

varying vec4 vFinalColor;
  

void main(void) {
 //Transformed normal position
 vec3 N = normalize(vec3(uNMatrix * vec4(aVertexNormal, 1.0)));
    
 //Normalize light to calculate lambertTerm
 vec3 L = normalize(uLightDirection);
 
 //Lambert's cosine law
 float lambertTerm = dot(N,-L);
 
 //Final Color
 vec4 addColor = vec4(aIndex, 0, aIndex, 1.0);
 vec4 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
 vFinalColor = Id + addColor; 
 vFinalColor.a = 1.0;
    
  //Transformed vertex position
  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition + vec3(aIndex, 0, aIndex), 1.0);
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

varying vec4  vFinalColor;

void main(void)  {
 gl_FragColor = vFinalColor;
}
</script>


<script id='code-js' type="text/javascript">

var gl = null; // WebGL context
var prg = null; // The program (shaders)
var c_width = 0; // Variable to store the width of the canvas
var c_height = 0; // Variable to store the height of the canvas

var mvMatrix = mat4.create(); // The Model-View matrix
var pMatrix = mat4.create(); // The projection matrix

/*-----------------------------------------------------*/
var nMatrix =  mat4.create();       // The normal matrix
/*-----------------------------------------------------*/

var sphereVerticesBuffer;
var sphereIndicesBuffer;
var dataArrayBuffer;

/*-----------------------------------------------------*/
var sphereNormalsBuffer;               //VBO for Normals
/*-----------------------------------------------------*/
var dropletIndicesBuffer;

var vertices;
var indices;
/*-----------------------------------------------------*/
var normals;              //JavaScript Array for Normals
/*-----------------------------------------------------*/
var dataArray;

var angle = 0;

/**
* The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
* what to do with every vertex and fragment that we pass it. 
* The vertex shader and the fragment shader together are called the program.
*/
function initProgram() {
    var fragmentShader          = utils.getShader(gl, "shader-fs");
    var vertexShader            = utils.getShader(gl, "shader-vs");

    prg = gl.createProgram();
    gl.attachShader(prg, vertexShader);
    gl.attachShader(prg, fragmentShader);
    gl.linkProgram(prg);

    if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(prg);

    prg.aVertexPosition  = gl.getAttribLocation(prg, "aVertexPosition");
	//prg.temp = gl.getAttribLocation(prg, "aTemp");
    prg.aVertexNormal    = gl.getAttribLocation(prg, "aVertexNormal");
	prg.aIndex = gl.getAttribLocation(prg, "aIndex");
	
	prg.uDataArray = gl.getUniformLocation(prg, "uDataArray");
	
    prg.uPMatrix         = gl.getUniformLocation(prg, "uPMatrix");
    prg.uMVMatrix        = gl.getUniformLocation(prg, "uMVMatrix");
    prg.uNMatrix         = gl.getUniformLocation(prg, "uNMatrix");

    prg.uMaterialDiffuse  = gl.getUniformLocation(prg, "uMaterialDiffuse");
    prg.uLightDiffuse     = gl.getUniformLocation(prg, "uLightDiffuse");
    prg.uLightDirection   = gl.getUniformLocation(prg, "uLightDirection");

}


function initLights(){
    gl.uniform3fv(prg.uLightDirection,    [0.0, -1.0, -1.0]);
    gl.uniform4fv(prg.uLightDiffuse,      [1.0,1.0,1.0,1.0]); 
    gl.uniform4fv(prg.uMaterialDiffuse,   [0.5,0.8,0.1,1.0]);
}

/**
* This function generates SPHERE data and creates the buffers
*/
function initBuffers()
{
    vertices = [-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0];
	indices = [0, 2, 1, 1, 2, 3];
	dataArray = [1.0, -1.0, 0.0, 1.0]; // create array with offsets
	dropletIndices = [0, 0, 0, 0, 1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5]; // this will differentiate between different 
	
	
	normals = utils.calculateNormals(vertices, indices);

	dropletIndicesBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, dropletIndicesBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dropletIndices), gl.STATIC_DRAW);
	
	dataArrayBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, dataArrayBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dataArray), gl.STATIC_DRAW);
	
    sphereVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    sphereNormalsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

    sphereIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

}

/**
* Main rendering function. Called every 500ms according to WebGLStart function (see below)
*/
function drawScene() {
    gl.clearColor(0.3,0.3,0.3, 1.0);
    gl.clearDepth(100.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);
    
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [0.0, 0.0, -5.5]); //Sets the camera to a reasonable distance to view the part
    
    gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
    gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);

    mat4.set(mvMatrix, nMatrix);
    mat4.inverse(nMatrix);
    mat4.transpose(nMatrix);
    
    gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);
	gl.uniformMatrix2fv(prg.uDataArray, false, dataArray); //
    
    try{
        gl.enableVertexAttribArray(prg.aVertexPosition);
		//gl.enableVertexAttribArray(prg.temp);
        gl.enableVertexAttribArray(prg.aVertexTexCoord);
        gl.enableVertexAttribArray(prg.aVertexNormal);
		gl.enableVertexAttribArray(prg.aIndex);
        
        //2. bind buffers 
		for (var i=0; i<3; i++){
			gl.bindBuffer(gl.ARRAY_BUFFER, dropletIndicesBuffer);
			gl.vertexAttribPointer(prg.aIndex, 1, gl.FLOAT, false, 0, i * 16);
		
			gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
			gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
			//gl.vertexAttribPointer(prg.temp, 3, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
			gl.vertexAttribPointer(prg.aVertexNormal,3,gl.FLOAT, false, 0,0);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,sphereIndicesBuffer);
			gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);

			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			console.log("Just Drew a Square");
		}
    }
    catch(err){
        alert(err);
        message(err.description);
    }
}





/**
* Render Loop
*/
function renderLoop() {
    requestAnimFrame(renderLoop);
    drawScene();
}

/**
* Entry point. This function is invoked when the page is loaded
*/
function runWebGLApp() {
    //Obtains a WebGL context
    gl = utils.getGLContext("canvas-element-id");
    //Initializes the program (shaders) 
    initProgram();
    //Initializes the buffers that we are going to use
    initBuffers();
    //Initializes lights
    initLights();
    //Renders the scene!
    renderLoop();
}
</script>
</head>

<body onLoad='runWebGLApp()'>
<div id='top'>
 <h1>WebGL Beginner's Guide - Chapter 3</h1>
 <h2>Goraud Shading + Lambertian Reflection Model</h2>
 <div id='logo-packt'><img src='packt.gif'/></div>
 <h3>Final Color = Id</h3>
</div>

<div id='contents'>
 <div id='canvasContainer'>
  <canvas id='canvas-element-id' width='480' height='400'>
   Your browser does not support the HTML5 canvas element.
  </canvas>
 </div>
    <div id='controls'>
        
    </div>
</div>

<div id='bottom'>
<table>
<tr>
<td>
<table>
  <caption>Light Direction</caption>
  <tr>
   <td>X:</td><td id='slider-x-value' width='30px' align='center'>0.0</td><td width='150px'><div id='slider-x'/></td>
  </tr>
  <tr>
   <td>Y:</td> <td id='slider-y-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-y'/></td>
  </tr>
  <tr>
   <td>Z:</td> <td id='slider-z-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-z'/></td>
  </tr>
 </table>
</td>
<td>
   <table>
   <tr>
             <td colspan="2"> Sphere Color (Material Diffuse Term:</td>
             <td>
                  <div id='colorSelectorSphere' class='colorSelector'><div style='background-color:rgb(128,204,26)'></div></div>
             </td>
    </tr>
    <tr>
         <td align='right'>Light Diffuse Term:</td>
         <td id='slider-ld-value'  width='30px'>1.0</td>
         <td width='150px' colspan='3'><div id='slider-ld'/></td>
     </tr>
    </table>
</td>
</tr>
</table>
</div>
<script>cview.run(cview.MODE_VIEW_AND_CONTROLS);</script>
<script>



function updateLightDiffuseTerm(){
 var ld = $('#slider-ld').slider("value");
 gl.uniform4fv(prg.uLightDiffuse,[ld,ld,ld,1.0]);
 $('#slider-ld-value').html(ld);
}

$('#slider-ld').slider({value:1.0, min:-0.01, max:1.01, step:0.01, slide:updateLightDiffuseTerm});


function updateLightDirection(){
   var x = $('#slider-x').slider("value");
   var y = $('#slider-y').slider("value");
   var z = $('#slider-z').slider("value");
   gl.uniform3fv(prg.uLightDirection, [x,y,z]);
   $('#slider-x-value').html(x);
   $('#slider-y-value').html(y);
   $('#slider-z-value').html(z);
}

$('#slider-x').slider({value:0.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-y').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-z').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});

function updateObjectColor(r,g,b){
    gl.uniform4fv(prg.uMaterialDiffuse,[r,g,b,1.0]); 
}

$('#colorSelectorSphere').ColorPicker({
    onSubmit: function(hsb, hex, rgb, el) {
   $(el).val(hex);
   $(el).ColorPickerHide();
   
 },
 color: '#00ff00',
    onShow: function (colpkr) {
        $(colpkr).fadeIn(500);
        return false;
    },
    onHide: function (colpkr) {
        $(colpkr).fadeOut(500);
        return false;
    },
    onChange: function (hsb, hex, rgb) {
        $('#colorSelectorSphere div').css('backgroundColor', '#' + hex);
        updateObjectColor(rgb.r/256,rgb.g/256,rgb.b/256);
    },
    
    onBeforeShow: function (colpkr) {
   $(colpkr).ColorPickerSetColor('rgb(0.5,0.8,0.1)');
  }
 })

</script>
</body>
</html>
