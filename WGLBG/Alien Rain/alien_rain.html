<html>

<head>
<title>WebGL Beginner's Guide - Chapter 3 - Goraud Shading + Lambertian Reflection Model</title>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<!-- CSS Styles //-->
<link href='css/style.css'   type='text/css' rel='stylesheet'>
<link href='css/desert.css'  type='text/css' rel='stylesheet'/>
<link href='css/colorpicker.css'  type='text/css' rel='stylesheet'/>
<link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />

<!-- JavaScript Libraries //-->
<script type='text/javascript' src='js/gl-matrix-min.js'></script>
<script type='text/javascript' src='js/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/prettify.js'></script>
<script type='text/javascript' src='js/utils.js'></script>
<script type='text/javascript' src='js/colorpicker.js'></script>
<script type='text/javascript' src='js/codeview.js'></script>

<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;

uniform vec3 uLightDirection;   //light direction
uniform vec4 uLightDiffuse;     //light color
uniform vec4 uMaterialDiffuse;  //object color

varying vec2 vTextureCoord;

varying vec4 vFinalColor;

void main(void) {
 //Transformed normal position
 vec3 N = normalize(vec3(uNMatrix * vec4(aVertexNormal, 1.0)));
    
 //Normalize light to calculate lambertTerm
 vec3 L = normalize(uLightDirection);
 
 //Lambert's cosine law
 float lambertTerm = dot(N,-L);
 
 //Final Color
 vec4 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
 vFinalColor = Id;
 vFinalColor.a = 1.0;
    
  //Transformed vertex position
  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  vTextureCoord = aTextureCoord;
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D uSampler;
varying vec2 vTextureCoord;
varying vec4  vFinalColor;

void main(void)  {
 gl_FragColor = texture2D(uSampler, vTextureCoord);

}
</script>


<script id='code-js' type="text/javascript">

var gl = null; // WebGL context
var prg = null; // The program (shaders)
var c_width = 0; // Variable to store the width of the canvas
var c_height = 0; // Variable to store the height of the canvas

var mvMatrix = mat4.create(); // The Model-View matrix
var pMatrix = mat4.create(); // The projection matrix

/*-----------------------------------------------------*/
var nMatrix =  mat4.create();       // The normal matrix
/*-----------------------------------------------------*/

var sphereVerticesBuffer;
var sphereIndicesBuffer;
var dataArrayBuffer;

/*-----------------------------------------------------*/
var sphereNormalsBuffer;               //VBO for Normals
/*-----------------------------------------------------*/
var dropletIndicesBuffer;
var cubeVertexTextureCoordBuffer;

var vertices;
var indices;
/*-----------------------------------------------------*/
var normals;              //JavaScript Array for Normals
/*-----------------------------------------------------*/
var textureCoords;
var affineTransformationsArray = [];

var angle = 0;

// Droplet Properties
var dropletQuantity = 100;
var speed = 0.01;
var rotationSpeed = 0.01;
var spread = 3000;

function initAffineTransformationsArray(){
	affineTransformationsArray = []; // start with an empty array
	for (var i = 0; i < dropletQuantity; i++) {
		affineTransformationsArray[i] = new Array(0, 0, 0, 0, 0, 0);
		// Random angles
		affineTransformationsArray[i][0] = ((Math.random() * 1000) % 360) ; 
		affineTransformationsArray[i][1] = ((Math.random() * 1000) % 360) ; 
		affineTransformationsArray[i][2] = ((Math.random() * 1000) % 360) ; 
		affineTransformationsArray[i][3] = ((Math.random() * 10000) % spread - spread/2) / 1000; 
		affineTransformationsArray[i][4] = 10-((Math.random() * 10000) % 10000) / 1000; 
		affineTransformationsArray[i][5] = ((Math.random() * 10000) % spread - spread/2) / 1000; 
	}
	console.log(affineTransformationsArray);
}

function updateAffineTransformationsArray(){
	for (var i = 0; i < dropletQuantity; i++) {
		// Random angles
		affineTransformationsArray[i][1] -= rotationSpeed; affineTransformationsArray[i][1] = affineTransformationsArray[i][1] % 360;  // fall
		affineTransformationsArray[i][4] -= speed; 
		if (affineTransformationsArray[i][4] < -5){
		    affineTransformationsArray[i][4] = 5;
		}
	}
}

/**
* The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
* what to do with every vertex and fragment that we pass it. 
* The vertex shader and the fragment shader together are called the program.
*/
function initProgram() {
    var fragmentShader          = utils.getShader(gl, "shader-fs");
    var vertexShader            = utils.getShader(gl, "shader-vs");

    prg = gl.createProgram();
    gl.attachShader(prg, vertexShader);
    gl.attachShader(prg, fragmentShader);
    gl.linkProgram(prg);

    if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(prg);

    prg.aVertexPosition  = gl.getAttribLocation(prg, "aVertexPosition");
    prg.aVertexNormal    = gl.getAttribLocation(prg, "aVertexNormal");
    prg.aTextureCoord = gl.getAttribLocation(prg, "aTextureCoord");
    gl.enableVertexAttribArray(prg.aTextureCoord);
	
    prg.uPMatrix         = gl.getUniformLocation(prg, "uPMatrix");
    prg.uMVMatrix        = gl.getUniformLocation(prg, "uMVMatrix");
    prg.uNMatrix         = gl.getUniformLocation(prg, "uNMatrix");

    prg.uMaterialDiffuse  = gl.getUniformLocation(prg, "uMaterialDiffuse");
    prg.uLightDiffuse     = gl.getUniformLocation(prg, "uLightDiffuse");
    prg.uLightDirection   = gl.getUniformLocation(prg, "uLightDirection");
    
    prg.samplerUniform = gl.getUniformLocation(prg, "uSampler");
}


function initLights(){
    gl.uniform3fv(prg.uLightDirection,    [0.0, -1.0, -1.0]);
    gl.uniform4fv(prg.uLightDiffuse,      [1.0,1.0,1.0,1.0]); 
    gl.uniform4fv(prg.uMaterialDiffuse,   [0.5,0.8,0.1,1.0]);
}

/**
* This function generates SPHERE data and creates the buffers
*/
function initBuffers()
{
    vertices = [-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0];
	indices = [0, 2, 1, 1, 2, 3];
	textureCoords = [
          // Front face
          0.0, 0.0,
          0.0, 1.0,
          1.0, 0.0,
          1.0, 1.0
    ];
	
	normals = utils.calculateNormals(vertices, indices);

	
	
	
    sphereVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);

    sphereNormalsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.DYNAMIC_DRAW);

    cubeVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.DYNAMIC_DRAW);

    sphereIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.DYNAMIC_DRAW);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

}

    var mvMatrixStack = [];

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }


    var neheTexture;

    function initTexture() {
        neheTexture = gl.createTexture();
        neheTexture.image = new Image();
        neheTexture.image.onload = function () {
            handleLoadedTexture(neheTexture);
        };

        neheTexture.image.src = "polaroid.jpg";
}

/**
* Main rendering function. Called every 500ms according to WebGLStart function (see below)
*/
function drawScene() {
    var temp = angle % 1.0;
    gl.clearColor(temp, temp, temp, 1.0);//0.9,0.9,0.9, 1.0);
    gl.clearDepth(100.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	
	
    mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);
    
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [0.0, 0.0, -5.5]); //Sets the camera to a reasonable distance to view the part
    
    
    
    try{
        gl.enableVertexAttribArray(prg.aVertexPosition);
        gl.enableVertexAttribArray(prg.aVertexNormal);
        mat4.rotate(mvMatrix, angle, [0,1,0]);
	    
        //2. bind buffers 
		for (var i=0; i < dropletQuantity; i++){
			//mat4.translate(mvMatrix, [qnt/100, -0.5, -0.5]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [affineTransformationsArray[i][3], affineTransformationsArray[i][4], affineTransformationsArray[i][5]]);
			mat4.rotate(mvMatrix, affineTransformationsArray[i][0], [1, 0, 0]);
			mat4.rotate(mvMatrix, affineTransformationsArray[i][1], [0, 1, 0]);
			mat4.rotate(mvMatrix, affineTransformationsArray[i][2], [0, 0, 1]);
			mat4.scale(mvMatrix, [0.5, 0.5, 0.5]);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
			gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
			gl.vertexAttribPointer(prg.aVertexNormal,3,gl.FLOAT, false, 0,0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
            gl.vertexAttribPointer(prg.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
    
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, neheTexture);
            gl.uniform1i(prg.samplerUniform, 0);
            
            gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
        	gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);
            
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
			
			gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			//console.log("Just Drew a Square");
			mvPopMatrix();
		}
    }
    catch(err){
        alert(err);
        //message(err.description);
    }
	


    mat4.set(mvMatrix, nMatrix);
    mat4.inverse(nMatrix);
    mat4.transpose(nMatrix);
    
    gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);
	
	updateAffineTransformationsArray();
	angle+=0.001;
}





/**
* Render Loop
*/
function renderLoop() {
    requestAnimFrame(renderLoop);
    drawScene();
}

/**
* Entry point. This function is invoked when the page is loaded
*/
function runWebGLApp() {
	initAffineTransformationsArray();
    //Obtains a WebGL context
    gl = utils.getGLContext("canvas-element-id");
    //Initializes the program (shaders) 
    initProgram();
    //Initializes the buffers that we are going to use
    initBuffers();
    //Initializes lights
    initLights();
    //Renders the scene!
    initTexture();
    renderLoop();
    audio.play();
}
</script>
</head>

<body onLoad='runWebGLApp()'>
<div id='top'>
 <h1>WebGL Beginner's Guide - Chapter 3</h1>
 <h2>Goraud Shading + Lambertian Reflection Model</h2>
 <div id='logo-packt'><img src='packt.gif'/></div>
 <h3>Final Color = Id</h3>
</div>

<div id='contents'>
 <div id='canvasContainer'>
  <canvas id='canvas-element-id' width='480' height='400'>
   Your browser does not support the HTML5 canvas element.
  </canvas>
 </div>
    <div id='controls'>
        
    </div>
</div>

<div id='bottom'>
<table>
<tr>
<td>
<table>
  <caption>Light Direction</caption>
  <tr>
   <td>X:</td><td id='slider-x-value' width='30px' align='center'>0.0</td><td width='150px'><div id='slider-x'/></td>
  </tr>
  <tr>
   <td>Y:</td> <td id='slider-y-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-y'/></td>
  </tr>
  <tr>
   <td>Z:</td> <td id='slider-z-value'  width='30px' align='center'>-1.0</td><td width='150px'><div id='slider-z'/></td>
  </tr>
 </table>
</td>
<td>
   <table>
   <tr>
             <td colspan="2"> Sphere Color (Material Diffuse Term:</td>
             <td>
                  <div id='colorSelectorSphere' class='colorSelector'><div style='background-color:rgb(128,204,26)'></div></div>
             </td>
    </tr>
    <tr>
         <td align='right'>Light Diffuse Term:</td>
         <td id='slider-ld-value'  width='30px'>1.0</td>
         <td width='150px' colspan='3'><div id='slider-ld'/></td>
     </tr>
    </table>
</td>
</tr>
</table>
</div>
<script>cview.run(cview.MODE_VIEW_AND_CONTROLS);</script>

<script>



function updateLightDiffuseTerm(){
 var ld = $('#slider-ld').slider("value");
 gl.uniform4fv(prg.uLightDiffuse,[ld,ld,ld,1.0]);
 $('#slider-ld-value').html(ld);
}

$('#slider-ld').slider({value:1.0, min:-0.01, max:1.01, step:0.01, slide:updateLightDiffuseTerm});


function updateLightDirection(){
   var x = $('#slider-x').slider("value");
   var y = $('#slider-y').slider("value");
   var z = $('#slider-z').slider("value");
   gl.uniform3fv(prg.uLightDirection, [x,y,z]);
   $('#slider-x-value').html(x);
   $('#slider-y-value').html(y);
   $('#slider-z-value').html(z);
}

$('#slider-x').slider({value:0.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-y').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});
$('#slider-z').slider({value:-1.0, min:-1.01, max:1.01, step:0.01, slide:updateLightDirection});

function updateObjectColor(r,g,b){
    gl.uniform4fv(prg.uMaterialDiffuse,[r,g,b,1.0]); 
}

$('#colorSelectorSphere').ColorPicker({
    onSubmit: function(hsb, hex, rgb, el) {
   $(el).val(hex);
   $(el).ColorPickerHide();
   
 },
 color: '#00ff00',
    onShow: function (colpkr) {
        $(colpkr).fadeIn(500);
        return false;
    },
    onHide: function (colpkr) {
        $(colpkr).fadeOut(500);
        return false;
    },
    onChange: function (hsb, hex, rgb) {
        $('#colorSelectorSphere div').css('backgroundColor', '#' + hex);
        updateObjectColor(rgb.r/256,rgb.g/256,rgb.b/256);
    },
    
    onBeforeShow: function (colpkr) {
   $(colpkr).ColorPickerSetColor('rgb(0.5,0.8,0.1)');
  }
 })

</script>
<audio id="audio" src="pics.mp3" preload="auto" autoplay></audio>
</body>
</html>
